{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Parsita","text":"<p>Parsita is a parser combinator library written in Python. Parser combinators provide an easy way to define a grammar using code so that the grammar itself effectively parses the source. They are not the fastest at parsing, but they are the easiest to write.</p> <p>Like all good parser combinator libraries, Parsita abuses operators to provide a clean grammar-like syntax. The <code>__or__</code> method is defined so that <code>|</code> tests between two alternatives. The <code>__and__</code> method is defined so that <code>&amp;</code> tests two parsers in sequence. Other operators are used as well.</p> <p>In a technique that I think is new to Python, Parsita uses metaclass magic to allow for forward declarations of values. This is important for parser combinators because grammars are often recursive or mutually recursive, meaning that some components must be used in the definition of others before they themselves are defined.</p>"},{"location":"#installation","title":"Installation","text":"<p>The recommended means of installation is with <code>pip</code> from PyPI.</p> <pre><code>pip install parsita\n</code></pre>"},{"location":"#hello-world","title":"Hello world","text":"<p>The following is a very basic parser for extracting the name from a <code>Hello, {name}!</code> string.</p> <pre><code>from parsita import *\n\nclass HelloWorldParsers(ParserContext, whitespace=r'[ ]*'):\n    hello_world = lit('Hello') &gt;&gt; ',' &gt;&gt; reg(r'[A-Z][a-z]*') &lt;&lt; '!'\n\n# A successful parse produces the parsed value\nname = HelloWorldParsers.hello_world.parse('Hello, David!').unwrap()\nassert name == 'David'\n\n# A parsing failure produces a useful error message\nname = HelloWorldParsers.hello_world.parse('Hello David!').unwrap()\n# parsita.state.ParseError: Expected ',' but found 'David'\n# Line 1, character 7\n#\n# Hello David!\n#       ^\n</code></pre>"},{"location":"alternative_parsers/","title":"Alternative parsers","text":""},{"location":"alternative_parsers/#parser1-parser2-alternative-parser","title":"<code>parser1 | parser2</code>: alternative parser","text":"<p>This tries to match <code>parser1</code> and <code>parser2</code>. If one succeeds and the other fails, it returns the value of the one that succeeded. If both succeed, it returns the value of the one that consumed more input in order to succeed. If both fail, it returns the failure message from whichever one got farther. Either side can be a bare string, but not both because <code>'a' | 'b'</code> tries to call <code>__or__</code> on <code>str</code> which fails. To try alternative literals, use <code>lit</code> with multiple arguments.</p> <pre><code>from parsita import *\n\nclass NumberParsers(ParserContext):\n    integer = reg(r'[-+]?[0-9]+') &gt; int\n    real = reg(r'[+-]?\\d+\\.\\d+(e[+-]?\\d+)?') | 'nan' | 'inf' &gt; float\n    number = real | integer\n\nassert NumberParsers.number.parse('4.0000') == Success(4.0)\n</code></pre> <p><code>a | b | c</code> is syntactic sugar for <code>longest(a, b, c)</code>. There is similar function <code>first(a, b, c)</code> that succeeds with the value of the first option to succeed instead of the one that consumed the most input. In most parsers, the first and longest alternative parsers have the same behavior, especially if the order of the alternatives is carefully considered. In version 1 of Parsita, the <code>a | b</code> syntax constructed a <code>first</code> parser. This was changed in version 2. If the old behavior of stopping on the first success is important, construct the parser with the <code>first</code> function to recover the old behavior.</p>"},{"location":"alternative_parsers/#longestparsers-longest-alternative-parser","title":"<code>longest(*parsers)</code>: longest alternative parser","text":"<p>This tries to match each parser supplied. After it has tried them all, it returns the result of the one that made the most progress, that is, consumed the most input. If none of the supplied parsers succeeds, then an error is returned corresponding to the parser that got farthest. If two or more parsers are successful and are tied for making the most progress, the result of the first such parser is returned.</p> <pre><code>from parsita import *\n\nclass ExpressionParsers(ParserContext):\n    name = reg(r'[a-zA-Z_]+')\n    function = name &amp; '(' &gt;&gt; expression &lt;&lt; ')'\n    expression = longest(name, function)\n\nassert ExpressionParsers.expression.parse('f(x)') == Success(['f', 'x'])\n</code></pre> <p>As of version 2 of Parsita, <code>longest</code> is the implementation behind the <code>a | b | c</code> syntax. It replaced <code>first</code>, which was the implementation in version 1.</p>"},{"location":"alternative_parsers/#firstparsers-first-alternative-parser","title":"<code>first(*parsers)</code>: first alternative parser","text":"<p>This tries to match each parser supplied. As soon as one parser succeeds, this returns with that parser's successful value. If later parsers would have succeeded, that is irrelevant because they are not tried. If all supplied parsers fail, this fails with the longest failure.</p> <pre><code>from parsita import *\n\nclass ExpressionParsers(ParserContext):\n    keyword = lit('pi', 'nan', 'inf')\n    name = reg(r'[a-zA-Z_]+')\n    function = name &amp; '(' &gt;&gt; expression &lt;&lt; ')'\n    expression = first(keyword, function, name)\n\nassert ExpressionParsers.expression.parse('f(x)') == Success(['f', 'x'])\nassert str(ExpressionParsers.expression.parse('pi(x)').failure()) == (\n    \"Expected end of source but found '('\\n\"\n    \"Line 1, character 3\\n\\n\"\n    \"pi(x)\\n\"\n    \"  ^  \"\n)\n# Note how the above fails because `keyword` is matched by `first` so that\n# `function`, which would have matched the input, was not tried.\n</code></pre> <p>In version 1 of Parsita, this was the implementation behind the <code>a | b | c</code> syntax. As of version 2, <code>longest</code> is used instead.</p>"},{"location":"alternative_parsers/#optparser-optional-parser","title":"<code>opt(parser)</code>: optional parser","text":"<p>An optional parser tries to match its argument. If the argument succeeds, it returns a list of length one with the successful value as its only element. If the argument fails, then <code>opt</code> succeeds anyway, but returns an empty list and consumes no input.</p> <pre><code>from parsita import *\n\nclass DeclarationParsers(ParserContext, whitespace=r'[ ]*'):\n    id = reg(r'[A-Za-z_][A-Za-z0-9_]*')\n    declaration = id &amp; opt(':' &gt;&gt; id)\n\nassert DeclarationParsers.declaration.parse('x: int') == Success(['x', ['int']])\nassert DeclarationParsers.declaration.parse('x') == Success(['x', []])\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Parsita is free and open source software developed under an MIT license. Development occurs at the GitHub project. Contributions, big and small, are welcome.</p> <p>Bug reports and feature requests may be made directly on the issues tab.</p> <p>To make a pull request, you will need to fork the repo, clone the repo, make the changes, run the tests, push the changes, and open a PR.</p>"},{"location":"contributing/#cloning-the-repo","title":"Cloning the repo","text":"<p>To make a local copy of Parsita, clone the repository with git:</p> <pre><code>git clone https://github.com/drhagen/parsita.git\n</code></pre>"},{"location":"contributing/#installing-from-source","title":"Installing from source","text":"<p>Parsita uses uv as its packaging and dependency manager. In whatever Python environment you prefer, install uv and then use uv to install Parsita and its dependencies:</p> <pre><code>pip install uv\nuv sync\n</code></pre>"},{"location":"contributing/#testing","title":"Testing","text":"<p>Parsita uses pytest to run the tests in the <code>tests/</code> directory. The test command is encapsulated with Nox:</p> <pre><code>uv run nox -s test\n</code></pre> <p>This will try to test with all compatible Python versions that <code>nox</code> can find. To run the tests with only a particular version, run something like this:</p> <pre><code>uv run nox -s test-3.13\n</code></pre> <p>It is good to run the tests locally before making a PR, but it is not necessary to have all Python versions run. It is rare for a failure to appear in a single version, and the CI will catch it anyway.</p>"},{"location":"contributing/#code-quality","title":"Code quality","text":"<p>Parsita uses Ruff and mypy to ensure a minimum standard of code quality. The code quality commands are encapsulated with Nox:</p> <pre><code>uv run nox -s format\nuv run nox -s lint\nuv run nox -s type_check\n</code></pre>"},{"location":"contributing/#generating-the-docs","title":"Generating the docs","text":"<p>Parsita uses MkDocs to generate HTML docs from Markdown. For development purposes, they can be served locally without needing to build them first:</p> <pre><code>uv run mkdocs serve\n</code></pre> <p>To deploy the current docs to GitHub Pages, Parsita uses the MkDocs <code>gh-deploy</code> command that builds the static site on the <code>gh-pages</code> branch, commits, and pushes to the origin:</p> <pre><code>uv run mkdocs gh-deploy\n</code></pre>"},{"location":"contributing/#making-a-release","title":"Making a release","text":"<ol> <li>Bump<ol> <li>Increment version in <code>pyproject.toml</code></li> <li>Run <code>uv lock</code></li> <li>Commit with message \"Bump version number to X.Y.Z\"</li> <li>Push commit to GitHub</li> <li>Check CI to ensure all tests pass</li> </ol> </li> <li>Tag<ol> <li>Tag commit with \"vX.Y.Z\"</li> <li>Push tag to GitHub</li> <li>Wait for build to finish</li> <li>Check PyPI for good upload</li> </ol> </li> <li>Publish to conda-forge<ol> <li>Fork parsita-feedstock</li> <li>Create branch with name <code>vX.Y.Z</code></li> <li>Update <code>recipe/meta.yaml</code><ul> <li>Update version</li> <li>Update sha256 to match source tarball on PyPI</li> <li>Reset build number to 0</li> <li>Update <code>requirements</code> and other project metadata</li> </ul> </li> <li>Commit with message \"updated vX.Y.Z\"</li> <li>Push to fork</li> <li>Open PR on upstream</li> <li>Wait for build to succeed</li> <li>Squash merge PR</li> </ol> </li> <li>Document<ol> <li>Create GitHub release with name \"Parsita X.Y.Z\" and major changes in body</li> <li>If appropriate, deploy updated docs</li> </ol> </li> </ol>"},{"location":"conversion_parsers/","title":"Conversion parsers","text":""},{"location":"conversion_parsers/#parser-function-conversion-parser","title":"<code>parser &gt; function</code>: conversion parser","text":"<p>Conversion parsers don't change how the text is parsed\u2014they change the value returned. Every parser returns a value when it succeeds. The function supplied must take a single argument (the successful value) and returns a new value. This is how text is converted to other objects and simpler objects built into larger ones. In accordance with Python's operator precedence, <code>&gt;</code> is the operator in Parsita with the loosest binding.</p> <pre><code>from parsita import *\n\nclass IntegerParsers(ParserContext):\n    integer = reg(r'[-+]?[0-9]+') &gt; int\n\nassert IntegerParsers.integer.parse('-128') == Success(-128)\n</code></pre>"},{"location":"conversion_parsers/#parser-function-transformation-parser","title":"<code>parser &gt;= function</code>: transformation parser","text":"<p>Transformation parsers pass the parsed output to a function which returns a new parser. This new parser is then immediately applied to the remaining input. There are two main uses for this parser.</p>"},{"location":"conversion_parsers/#fallible-conversion","title":"Fallible conversion","text":"<p>The first use is as a fallible conversion parser. The conversion parser cannot tolerate failure. From the conversion parser's perspective, by the time the parsed output gets to the conversion function, parsing has already succeeded, just the output value is being changed. If the parsing needs to fail, then the transformation parser can be used. The transformer function can return a <code>SuccessParser</code> with <code>success</code> or a <code>FailureParser</code> with <code>failure</code> to declare success or failure based on its calculation.</p> <p>The <code>TransformationParser</code> is basically equivalent to a <code>PredicateParser</code> followed by a <code>ConversionParser</code>. Where you would otherwise write <code>pred(parser, is_valid_object) &gt; create_object</code>, you can write <code>parser &gt;= maybe_create_object</code>, instead.</p> <pre><code>from dataclasses import dataclass\n\nfrom parsita import *\n\n@dataclass\nclass Percent:\n    number: int\n\ndef to_percent(number: int) -&gt; Parser[str, Percent]:\n    if not 0 &lt;= number &lt;= 100:\n        return failure(\"a number between 0 and 100\")\n    else:\n        return success(Percent(number))\n\nclass PercentParsers(ParserContext):\n    percent = (reg(r\"[0-9]+\") &gt; int) &gt;= to_percent\n\nassert PercentParsers.percent.parse('50') == Success(Percent(50))\nassert isinstance(PercentParsers.percent.parse('150'), Failure)\n</code></pre> <p>In the current version of Parsita, the error messages that come from this leave something to be desired. Right now in the core of Parsita, there is no way to separately specify where in the input parsing failed or what the actual token was. The location of the failure is always the farther point that input was consumed and the actual token is always the next token from that point. That means that the error message will always mark the token after what was successfully consumed and passed to <code>&gt;=</code> before it was converted into a failure.</p>"},{"location":"conversion_parsers/#parsers-parameterized-by-previous-input","title":"Parsers parameterized by previous input","text":"<p>The second use is to parse later text based on previous text. This is incredibly powerful, but in my experience, not that useful. When viewing parser combinators as a monad, this is the <code>bind</code> operation, so functional programming enthusiasts are really into it. It is only included in Parsita because it came free with the fallible conversion parser use case above.</p> <pre><code>from parsita import *\n\ndef select_parser(type: str):\n    if type == 'int':\n        return reg(r\"[0-9]+\") &gt; int\n    elif type == 'decimal':\n        return reg(r\"[0-9]+\\.[0-9]+\") &gt; float\n\nclass NumberParsers(ParserContext, whitespace=r'[ ]*'):\n    type = lit('int', 'decimal')\n    number = type &gt;= select_parser\n\nassert NumberParsers.number.parse('int 5') == Success(5)\nassert isinstance(NumberParsers.number.parse('int 2.0'), Failure)\n</code></pre>"},{"location":"getting_started/","title":"Getting started","text":"<p>David Hagen gave an introductory talk on Parsita at SciPy 2021. The documentation is more thorough, but the talk is useful for anyone looking for a quick walk-through.</p> <p>Strictly speaking, Parsita parsers can parse any kind of sequence, <code>str</code>, <code>bytes</code>, <code>list[Token]</code>, etc. As long as the arguments to the terminal parsers match the input sequence, everything will work. However, this documentation will focus exclusively on parsing <code>str</code> because parsing text is most accessible to beginners.</p>"},{"location":"getting_started/#defining-a-parser","title":"Defining a parser","text":"<p>Parsita parsers are written inside the bodies of classes that inherit from <code>ParserContext</code>. Such classes are not meant to be instantiated. They are used purely as a kind of souped-up context manager.</p> <p>The metaclass of <code>ParserContext</code> takes a <code>whitespace</code> named argument, which is a regular expression, or more commonly, a string that can be parsed into a regular expression, or less commonly, an arbitrary <code>Parser</code>. This becomes the definition of whitespace for all <code>Parser</code>s defined in this class body, making it so that whitespace as defined does not need to be explicitly captured and discarded. With the default <code>whitespace=None</code>, no whitespace is ignored. Common values for whitespace are:</p> <ul> <li><code>whitespace=r'[ ]*'</code> to ignore spaces</li> <li><code>whitespace=r'[ \\t]*'</code> to ignore spaces and tabs</li> <li><code>whitespace=r'\\s*'</code> to ignore all whitespace including newlines</li> </ul> <pre><code>from parsita import *\n\nclass NumericListParsers(ParserContext, whitespace=r'[ ]*'):\n    integer_list = '[' &gt;&gt; repsep(reg('[+-]?[0-9]+') &gt; int, ',') &lt;&lt; ']'\n</code></pre> <p>Pretty much every function in Parsita returns an object with type <code>Parser</code>. Various operators, like <code>&amp;</code> and <code>|</code>, are defined so that <code>Parser</code>s can be combined to make new, more complex, parsers, hence the name \"parser combinators\".</p> <p>In version 1 of Parsita, <code>ParserContext</code> was split into two context classes, one with a default whitespace of <code>None</code> and the other with a default whitespace of <code>r'\\s*'</code>. This was considered heavyweight, so they were combined into a single context.</p>"},{"location":"getting_started/#invoking-a-parser","title":"Invoking a parser","text":""},{"location":"getting_started/#parserparse","title":"<code>Parser.parse</code>","text":"<p>The only method of note on a <code>Parser</code> is the <code>parse</code> method. The <code>parse</code> method takes a <code>str</code> as as argument and returns an instance of the <code>Result</code> class, which has two subclasses <code>Success</code> and <code>Failure</code>. Note that in v2.0, these classes are reexported by Parsita, but are defined by the popular Returns package in <code>returns.result</code>. By using the <code>Result</code> class from Returns, Parsita's error handling can be composed with that of other libraries that use Returns.</p> <p>Instances of <code>Result</code> work especially well with pattern matching in the <code>match</code> statement introduced in Python 3.10:</p> <pre><code>from parsita import *\n\nclass NumericListParsers(ParserContext, whitespace=r'[ ]*'):\n    integer_list = '[' &gt;&gt; repsep(reg('[+-]?[0-9]+') &gt; int, ',') &lt;&lt; ']'\n\nresult = NumericListParsers.integer_list.parse('[1, 1, 2, 3, 5]')\n\nmatch result:\n    case Success(value):\n        python_list = value\n    case Failure(error):\n        raise error\n</code></pre> <p>If working in a version of Python prior to 3.10, you can use <code>isinstance</code> directly:</p> <pre><code>from parsita import *\n\nclass NumericListParsers(ParserContext, whitespace=r'[ ]*'):\n    integer_list = '[' &gt;&gt; repsep(reg('[+-]?[0-9]+') &gt; int, ',') &lt;&lt; ']'\n\nresult = NumericListParsers.integer_list.parse('[1, 1, 2, 3, 5]')\n\nif isinstance(result, Success):\n    python_list = result.unwrap()\nelif isinstance(result, Failure):\n    raise result.failure()\n</code></pre> <p>Returns has lots of features related to the <code>Result</code> class not covered here. One of the useful features that is not a method on <code>Result</code> is <code>returns.pipeline.is_successful</code>, which may be useful for those on Python versions without pattern matching.</p>"},{"location":"miscellaneous_parsers/","title":"Miscellaneous parsers","text":""},{"location":"miscellaneous_parsers/#predparser-predicate-description-predicate-parser","title":"<code>pred(parser, predicate, description)</code>: predicate parser","text":"<p>A predicate parser matches <code>parser</code> and, if it succeeds, runs a test function <code>predicate</code> on the return value. If <code>predicate</code> returns <code>True</code>, the predicate parser succeeds, returning the same value; if it returns <code>False</code>, the parser fails with the message that it is expecting <code>description</code>.</p> <pre><code>from parsita import *\n\nclass IntervalParsers(ParserContext, whitespace=r'[ ]*'):\n    number = reg('\\d+') &gt; int\n    pair = '[' &gt;&gt; number &lt;&lt; ',' &amp; number &lt;&lt; ']'\n    interval = pred(pair, lambda x: x[0] &lt;= x[1], 'ordered pair')\n\nassert IntervalParsers.interval.parse('[1, 2]') == Success([1, 2])\nassert IntervalParsers.interval.parse('[2, 1]') != Success([2, 1])\n</code></pre>"},{"location":"miscellaneous_parsers/#untilparser-consume-until-parser-matches","title":"<code>until(parser):</code>: consume until parser matches","text":"<p>A parser that consumes input until the member parser succeeds. The input matched by the member parser is not consumed. It acts kind of like lookahead. The returned value is all consumed input.</p> <p>The user should be warned that this parser is kind of slow, especially when applied directly to text. This is because, when the member parser fails, it tries again at the next character and the next character until it succeeds. Walking one character at a time can be computationally expensive.</p> <p>One of the obvious uses of the <code>until</code> parser is combining it with the transformation parser in order to implement heredocs.</p> <pre><code>from parsita import *\n\nclass TestParser(ParserContext, whitespace=r'\\s*'):\n    heredoc = reg(\"[A-Za-z]+\") &gt;= (lambda token: until(token) &lt;&lt; token)\n\ncontent = \"EOF\\nAnything at all\\nEOF\"\nassert TestParser.heredoc.parse(content) == Success(\"Anything at all\\n\")\n</code></pre>"},{"location":"miscellaneous_parsers/#any1-any-one-element","title":"<code>any1</code>: any one element","text":"<p>A parser that matches any single input element. This is not a particularly useful parser when parsing text (for which <code>reg(r'.')</code> would be more standard). But when parsing other types of input, this is useful as the first argument to <code>pred</code> when one merely wants to run the predicate on a single token. This parser can only fail at the end of the stream. Note that <code>any1</code> is not a function\u2014it is a complete parser itself.</p> <pre><code>from parsita import *\n\nclass DigitParsers(ParserContext):\n    digit = pred(any1, lambda x: x['type'] == 'digit', 'a digit') &gt; \\\n        (lambda x: x['payload'])\n\nassert DigitParsers.digit.parse([{'type': 'digit', 'payload': 3}]) == \\\n    Success(3)\n</code></pre>"},{"location":"miscellaneous_parsers/#eof-end-of-file","title":"<code>eof</code>: end of file","text":"<p>A parser than matches the end of the input stream. It is not necessary to include this on every parser. The <code>parse</code> method on every parser is successful only if it matches the entire input. The <code>eof</code> parser is only needed to indicate that the preceding parser is only valid at the end of the input. Most commonly, it is used an alternative to an end token when the end token may be omitted at the end of the input. Note that <code>eof</code> is not a function\u2014it is a complete parser itself.</p> <pre><code>from parsita import *\n\nclass OptionsParsers(ParserContext):\n    option = reg(r'[A-Za-z]+') &lt;&lt; '=' &amp; reg(r'[A-Za-z]+') &lt;&lt; (';' | eof)\n    options = rep(option)\n\nassert OptionsParsers.options.parse('log=warn;detail=minimal;') == \\\n    Success([['log', 'warn'], ['detail', 'minimal']])\nassert OptionsParsers.options.parse('log=warn;detail=minimal') == \\\n    Success([['log', 'warn'], ['detail', 'minimal']])\n</code></pre>"},{"location":"miscellaneous_parsers/#fwd-forward-declaration","title":"<code>fwd()</code>: forward declaration","text":"<p>This creates a forward declaration for a parser to be defined later. This function is not typically needed because forward declarations are created automatically within the class bodies of subclasses of <code>ParserContext</code>, which is the recommended way to use Parsita. This function exists so you can create a forward declaration manually because you are either working outside of the magic classes or wish to define them manually to make your IDE happier.</p> <p>To use <code>fwd</code>, first assign <code>fwd()</code> to a variable, then use that variable in other combinators like any other parser, then call the <code>define(parser: Parser)</code> method on the object to provide the forward declaration with its definition. The forward declaration will now look and act like the definition provided.</p> <pre><code>from parsita import *\n\nclass AddingParsers(ParserContext):\n    number = reg(r'[+-]?\\d+') &gt; int\n    expr = fwd()\n    base = '(' &gt;&gt; expr &lt;&lt; ')' | number\n    expr.define(rep1sep(base, '+') &gt; sum)\n\nassert AddingParsers.expr.parse('2+(1+2)+3') == Success(8)\n</code></pre>"},{"location":"miscellaneous_parsers/#successvalue-always-succeed-with-value","title":"<code>success(value)</code>: always succeed with value","text":"<p>This parser always succeeds with the given <code>value</code> of an arbitrary type while consuming no input. Its utility is limited to inserting arbitrary values into complex parsers, often as a placeholder for unimplemented code. Usually, these kinds of values are better inserted as a post processing step or with a conversion parser <code>&gt;</code>, but for prototyping, this parser can be convenient.</p> <pre><code>from parsita import *\n\nclass HostnameParsers(ParserContext):\n    port = success(80)  # TODO: do not just ignore other ports\n    host = rep1sep(reg('[A-Za-z0-9]+([-]+[A-Za-z0-9]+)*'), '.')\n    server = host &amp; port\n\nassert HostnameParsers.server.parse('drhagen.com') == Success([['drhagen', 'com'], 80])\n</code></pre>"},{"location":"miscellaneous_parsers/#failureexpected-always-fail-with-message","title":"<code>failure(expected)</code>: always fail with message","text":"<p>This parser always fails with a message that it is expecting the given string <code>expected</code>. Its utility is limited to marking sections of code as either not yet implemented or providing a better error message for common bad input. Usually, these kinds of messages are better crafted as a postprocessing step following parsing, but for prototyping, they can be inserted with this parser.</p> <pre><code>from parsita import *\n\nclass HostnameParsers(ParserContext):\n    # TODO: implement allowing different port\n    port = lit('80') | reg('[0-9]+') &amp; failure('no other port than 80')\n    host = rep1sep(reg('[A-Za-z0-9]+([-]+[A-Za-z0-9]+)*'), '.')\n    server = host &lt;&lt; ':' &amp; port\n\nassert str(HostnameParsers.server.parse('drhagen.com:443').failure()) == (\n    'Expected no other port than 80 but found end of source'\n)\n</code></pre>"},{"location":"miscellaneous_parsers/#debugparser-verbosefalse-callbacknone-debug-a-parser","title":"<code>debug(parser, *, verbose=False, callback=None)</code>: debug a parser","text":"<p>This parser does not affect input or output in any way. It merely provides a verbose flag and hook to run a callback. The default for the verbose flag is <code>False</code> and the default for the callback is <code>None</code>, so by default, <code>debug</code> does absolutely nothing. If <code>verbose</code> is set to <code>True</code>, then the input location is printed before the member parser is invoked and the result is printed after the member parser has returned.</p> <p>The callback has the signature <code>(parser: Parser[Input, Output], reader: Reader[Input]) -&gt; None</code> and will be given the member parser and the reader at the current position.</p> <p>As the name suggests, this is useful only for debugging purposes. The only place one can reliably put a breakpoint in a parser is in the callback of this parser. The conversion parser can be used to place breakpoints, but only after the member parser has run and only on success, making it not very useful for debugging.</p> <pre><code>from decimal import Decimal\n\nfrom parsita import *\n\ndef temp(parser, reader):\n    # Can put a breakpoint here to inspect why the decimal parser is capturing\n    # Spoiler: use `\\.` instead of `.` in regexes\n    pass\n\nclass NumberParsers(ParserContext):\n    integer = reg(r'[-+]?[0-9]+') &gt; int\n    decimal = debug(reg(r'[-+]?[0-9]+.[0-9]+'), callback=temp) &gt; Decimal\n    scientific = reg(r'[-+]?[0-9]+e[-+]?[0-9]+') &gt; float\n    number = decimal | scientific | integer\n\n# Assertion is broken and needs debugged\nassert isinstance(NumberParsers.number.parse('1e5').unwrap(), float)\n</code></pre>"},{"location":"repeated_parsers/","title":"Repeated parsers","text":""},{"location":"repeated_parsers/#repparser-min0-maxinf-and-rep1parser-repeated-parsers","title":"<code>rep(parser, min=0, max=inf)</code> and <code>rep1(parser)</code>: repeated parsers","text":"<p>A repeated parser matches repeated instances of its parser argument. It returns a list with each element being the value of one match. <code>rep</code> only succeeds if it matches at least <code>min</code> times and will only consume up to <code>max</code> matches. <code>rep1</code> is syntactic sugar for <code>min=1</code>. If <code>min=0</code>, then <code>rep</code> always succeeds, returning an empty list if no matches are found.</p> <pre><code>from parsita import *\n\nclass SummationParsers(ParserContext, whitespace=r'[ ]*'):\n    integer = reg(r'[-+]?[0-9]+') &gt; int\n    summation = integer &amp; rep('+' &gt;&gt; integer) &gt; (lambda x: sum([x[0]] + x[1]))\n\nassert SummationParsers.summation.parse('1 + 1 + 2 + 3 + 5') == Success(12)\n</code></pre>"},{"location":"repeated_parsers/#repsepparser-separator-min0-maxinf-and-rep1sepparser-separator-repeated-separated-parsers","title":"<code>repsep(parser, separator, min=0, max=inf)</code> and <code>rep1sep(parser, separator)</code>: repeated separated parsers","text":"<p>A repeated separated parser matches parser separated by separator, returning a list of the values returned by parser and discarding the value of separator. <code>repsep</code> only succeeds if it matches at least <code>min</code> times and will only consume up to <code>max</code> matches. <code>rep1sep</code> is syntactic sugar for <code>min=1</code>. If <code>min=0</code>, then <code>repsep</code> always succeeds, returning an empty list if no matches are found.</p> <pre><code>from parsita import *\n\nclass ListParsers(ParserContext, whitespace=r'[ ]*'):\n    integer = reg(r'[-+]?[0-9]+') &gt; int\n    my_list = '[' &gt;&gt; repsep(integer, ',') &lt;&lt; ']'\n\nassert ListParsers.my_list.parse('[1,2,3]') == Success([1, 2, 3])\n</code></pre>"},{"location":"sequential_parsers/","title":"Sequential parser","text":""},{"location":"sequential_parsers/#parser1-parser2-sequential-parser","title":"<code>parser1 &amp; parser2</code>: sequential parser","text":"<p>All the previous parsers will match at most one thing. This is the syntax for matching one parser and then another after it. If working in a <code>ParserContext</code>, the two may be separated by whitespace. The value returned is a list of all the values returned by each parser. If there are multiple parsers separated by <code>&amp;</code>, a list of the same length as the number of parsers is returned. Like <code>|</code>, either side may be a bare string, but not both. In accordance with Python's operator precedence, <code>&amp;</code> binds more tightly than <code>|</code>.</p> <pre><code>from parsita import *\n\nclass UrlParsers(ParserContext):\n    url = lit('http', 'ftp') &amp; '://' &amp; reg(r'[^/]+') &amp; reg(r'.*')\n\nassert UrlParsers.url.parse('http://drhagen.com/blog/sane-equality/') == \\\n    Success(['http', '://', 'drhagen.com', '/blog/sane-equality/'])\n</code></pre>"},{"location":"sequential_parsers/#parser1-parser2-and-parser1-parser2-discard-left-and-right-parsers","title":"<code>parser1 &gt;&gt; parser2</code> and <code>parser1 &lt;&lt; parser2</code>: discard left and right parsers","text":"<p>The discard left and discard right parser match the exact same text as <code>parser1 &amp; parser2</code>, but rather than return a list of values from both, the left value in <code>&gt;&gt;</code> and the right value in <code>&lt;&lt;</code> is discarded so that only the remaining value is returned. A mnemonic to help remember which is which is to imagine the symbols as open mouths eating the parser to be discarded.</p> <pre><code>from parsita import *\n\nclass PointParsers(ParserContext, whitespace=r'[ ]*'):\n    integer = reg(r'[-+]?[0-9]+') &gt; int\n    point = '(' &gt;&gt; integer &lt;&lt; ',' &amp; integer &lt;&lt; ')'\n\nassert PointParsers.point.parse('(4, 3)') == Success([4, 3])\n</code></pre>"},{"location":"terminal_parsers/","title":"Terminal parsers","text":"<p>Terminal parsers (those created by <code>lit</code> and <code>reg</code>) are the atoms of a parser, they match and extract the smallest meaningful words of the language.</p> <p>You could say that they recognize the tokens of the language being parsed, but Parsita does not really have a concept of tokens, at least when <code>str</code> is the input type. Terminal parsers chew directly on the input string.</p>"},{"location":"terminal_parsers/#litliterals-literal-parser","title":"<code>lit(*literals)</code>: literal parser","text":"<p>This is the simplest parser. It matches the exact string provided and returns the string as its value. If multiple arguments are provided, it tries each one in succession, returning the first one it finds.</p> <pre><code>from parsita import *\n\nclass HelloParsers(ParserContext):\n    hello = lit('Hello World!')\n\nassert HelloParsers.hello.parse('Hello World!') == Success('Hello World!')\nassert isinstance(HelloParsers.hello.parse('Goodbye'), Failure)\n</code></pre> <p>In most cases, the call to <code>lit</code> is handled automatically. If a bare string is provided to the functions and operators of Parsita, it will be promoted to a literal parser whenever possible. Only when an operator is between two Python types, like a string and a string <code>'a' | 'b'</code> or a string and function <code>'100' &gt; int</code> will this \"implicit conversion\" not take place and you have to use <code>lit</code> (e.g. <code>lit('a', 'b')</code> and <code>lit('100') &gt; int</code>).</p>"},{"location":"terminal_parsers/#regpattern-regular-expression-parser","title":"<code>reg(pattern)</code>: regular expression parser","text":"<p>Like <code>lit</code>, this matches a string and returns it, but the matching is done with a regular expression.</p> <pre><code>from parsita import *\n\nclass IntegerParsers(ParserContext):\n    integer = reg(r'[-+]?[0-9]+')\n\nassert IntegerParsers.integer.parse('-128') == Success('-128')\n</code></pre>"},{"location":"utility_functions/","title":"Utility functions","text":"<p>There are several utility functions, <code>constant</code>, <code>splat</code>, and <code>unsplat</code>. They are mostly useful when used with the conversion parser (<code>&gt;</code>). These utility functions are not exported by <code>from parsita import *</code> and must be imported from <code>parsita.util</code>.</p>"},{"location":"utility_functions/#constantvalue-create-a-function-that-always-returns-the-same-value","title":"<code>constant(value)</code>: create a function that always returns the same value","text":"<p>The function <code>constant(value: A) -&gt; Callable[..., A]</code> accepts any single value and returns a function. The function takes any number of arguments of any types and returns <code>value</code>. It is useful for defining parsers (usually of a particular literal) that evaluate to a particular value.</p> <pre><code>from parsita import *\nfrom parsita.util import constant\n\nclass BooleanParsers(ParserContext):\n    true = lit('true') &gt; constant(True)\n    false = lit('false') &gt; constant(False)\n    boolean = true | false\n\nassert BooleanParsers.boolean.parse('false') == Success(False)\n</code></pre>"},{"location":"utility_functions/#splatfunction-convert-a-function-of-many-arguments-to-take-only-one-list-argument","title":"<code>splat(function)</code>: convert a function of many arguments to take only one list argument","text":"<p>The function <code>splat(function: Callable[tuple[*B], A]) -&gt; Callable[tuple[tuple[*B]], A]</code> has a complicated type signature, but does a simple thing. It takes a single function that takes multiple arguments and converts it to a function that takes only one argument, which is a list of all original arguments. It is particularly useful for passing a list of results from a sequential parser <code>&amp;</code> to a function that takes each element as an separate argument. By applying <code>splat</code> to the function, it now takes the single list that is returned by the sequential parser.</p> <pre><code>from collections import namedtuple\nfrom parsita import *\nfrom parsita.util import splat\n\nUrl = namedtuple('Url', ['host', 'port', 'path'])\n\nclass UrlParsers(ParserContext):\n    host = reg(r'[A-Za-z0-9.]+')\n    port = reg(r'[0-9]+') &gt; int\n    path = reg(r'[-._~A-Za-z0-9/]*')\n    url = 'https://' &gt;&gt; host &lt;&lt; ':' &amp; port &amp; path &gt; splat(Url)\nassert UrlParsers.url.parse('https://drhagen.com:443/blog/') == \\\n    Success(Url('drhagen.com', 443, '/blog/'))\n</code></pre>"},{"location":"utility_functions/#unsplatfunction-convert-a-function-of-one-list-argument-to-take-many-arguments","title":"<code>unsplat(function)</code>: convert a function of one list argument to take many arguments","text":"<p>The function <code>unsplat(function: Callable[tuple[tuple[*B]], A]) -&gt; Callable[tuple[*B], A]</code> does the opposite of <code>splat</code>. It takes a single function that takes a single argument that is a list and converts it to a function that takes multiple arguments, each of which was an element of the original list. It is not very useful for writing parsers because the conversion parser always calls its converter function with a single argument, but is included here to complement <code>splat</code>.</p> <pre><code>from parsita.util import splat, unsplat\n\ndef sum_args(*x):\n    return sum(x)\n\ndef sum_list(x):\n    return sum(x)\n\nsplatted_sum_args = splat(sum_args)\nunsplatted_sum_list = unsplat(sum_list)\n\nassert unsplatted_sum_list(2, 3, 5) == sum_args(2, 3, 5)\nassert splatted_sum_args([2, 3, 5]) == sum_list([2, 3, 5])\n</code></pre>"}]}