{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Parsita Parsita is a parser combinator library written in Python. Parser combinators provide an easy way to define a grammar using code so that the grammar itself effectively parses the source. They are not the fastest at parsing, but they are the easiest to write. Like all good parser combinator libraries, Parsita abuses operators to provide a clean grammar-like syntax. The __or__ method is defined so that | tests between two alternatives. The __and__ method is defined so that & tests two parsers in sequence. Other operators are used as well. In a technique that I think is new to Python, Parsita uses metaclass magic to allow for forward declarations of values. This is important for parser combinators because grammars are often recursive or mutually recursive, meaning that some components must be used in the definition of others before they themselves are defined. Installation The recommended means of installation is with pip from PyPI. pip install parsita Hello world The following is a very basic parser for extracting the name from a Hello, {name}! string. from parsita import * class HelloWorldParsers ( TextParsers , whitespace = r '[ ]*' ): hello_world = lit ( 'Hello' ) >> ',' >> reg ( r '[A-Z][a-z]*' ) << '!' # A successful parse produces the parsed value name = HelloWorldParsers . hello_world . parse ( 'Hello, David!' ) . or_die () assert name == 'David' # A parsing failure produces a useful error message name = HelloWorldParsers . hello_world . parse ( 'Hello David!' ) . or_die () # parsita.state.ParseError: Expected ',' but found 'David' # Line 1, character 7 # # Hello David! # ^","title":"Home"},{"location":"#parsita","text":"Parsita is a parser combinator library written in Python. Parser combinators provide an easy way to define a grammar using code so that the grammar itself effectively parses the source. They are not the fastest at parsing, but they are the easiest to write. Like all good parser combinator libraries, Parsita abuses operators to provide a clean grammar-like syntax. The __or__ method is defined so that | tests between two alternatives. The __and__ method is defined so that & tests two parsers in sequence. Other operators are used as well. In a technique that I think is new to Python, Parsita uses metaclass magic to allow for forward declarations of values. This is important for parser combinators because grammars are often recursive or mutually recursive, meaning that some components must be used in the definition of others before they themselves are defined.","title":"Parsita"},{"location":"#installation","text":"The recommended means of installation is with pip from PyPI. pip install parsita","title":"Installation"},{"location":"#hello-world","text":"The following is a very basic parser for extracting the name from a Hello, {name}! string. from parsita import * class HelloWorldParsers ( TextParsers , whitespace = r '[ ]*' ): hello_world = lit ( 'Hello' ) >> ',' >> reg ( r '[A-Z][a-z]*' ) << '!' # A successful parse produces the parsed value name = HelloWorldParsers . hello_world . parse ( 'Hello, David!' ) . or_die () assert name == 'David' # A parsing failure produces a useful error message name = HelloWorldParsers . hello_world . parse ( 'Hello David!' ) . or_die () # parsita.state.ParseError: Expected ',' but found 'David' # Line 1, character 7 # # Hello David! # ^","title":"Hello world"},{"location":"alternative_parsers/","text":"Alternative parsers parser1 | parser2 : alternative parser This tries to match parser1 . If it fails, it then tries to match parser2 . If both fail, it returns the failure message from whichever one got farther. Either side can be a bare string, not both because 'a' | 'b' tries to call __or__ on str which fails. To try alternative literals, use lit with multiple arguments. from parsita import * class NumberParsers ( TextParsers ): integer = reg ( r '[-+]?[0-9]+' ) > int real = reg ( r '[+-]?\\d+\\.\\d+(e[+-]?\\d+)?' ) | 'nan' | 'inf' > float number = real | integer assert NumberParsers . number . parse ( '4.0000' ) == Success ( 4.0 ) opt(parser) : optional parser An optional parser tries to match its argument. If the argument succeeds, it returns a list of length one with the successful value as its only element. If the argument fails, then opt succeeds anyway, but returns an empty list and consumes no input. from parsita import * class DeclarationParsers ( TextParsers ): id = reg ( r '[A-Za-z_][A-Za-z0-9_]*' ) declaration = id & opt ( ':' >> id ) assert DeclarationParsers . declaration . parse ( 'x: int' ) == Success ([ 'x' , [ 'int' ]]) assert DeclarationParsers . declaration . parse ( 'x' ) == Success ([ 'x' , []])","title":"Alternative parsers"},{"location":"alternative_parsers/#alternative-parsers","text":"","title":"Alternative parsers"},{"location":"alternative_parsers/#parser1-parser2-alternative-parser","text":"This tries to match parser1 . If it fails, it then tries to match parser2 . If both fail, it returns the failure message from whichever one got farther. Either side can be a bare string, not both because 'a' | 'b' tries to call __or__ on str which fails. To try alternative literals, use lit with multiple arguments. from parsita import * class NumberParsers ( TextParsers ): integer = reg ( r '[-+]?[0-9]+' ) > int real = reg ( r '[+-]?\\d+\\.\\d+(e[+-]?\\d+)?' ) | 'nan' | 'inf' > float number = real | integer assert NumberParsers . number . parse ( '4.0000' ) == Success ( 4.0 )","title":"parser1 | parser2: alternative parser"},{"location":"alternative_parsers/#optparser-optional-parser","text":"An optional parser tries to match its argument. If the argument succeeds, it returns a list of length one with the successful value as its only element. If the argument fails, then opt succeeds anyway, but returns an empty list and consumes no input. from parsita import * class DeclarationParsers ( TextParsers ): id = reg ( r '[A-Za-z_][A-Za-z0-9_]*' ) declaration = id & opt ( ':' >> id ) assert DeclarationParsers . declaration . parse ( 'x: int' ) == Success ([ 'x' , [ 'int' ]]) assert DeclarationParsers . declaration . parse ( 'x' ) == Success ([ 'x' , []])","title":"opt(parser): optional parser"},{"location":"contributing/","text":"Contributing Parsita is free and open source software developed under an MIT license. Development occurs at the GitHub project . Contributions, big and small, are welcome. Bug reports and feature requests may be made directly on the issues tab. To make a pull request, you will need to fork the repo, clone the repo, make the changes, run the tests, push the changes, and open a PR . Cloning the repo To make a local copy of Parsita, clone the repository with git: git clone https://github.com/drhagen/parsita.git Installing from source Parsita uses Poetry as its packaging and dependency manager. In whatever Python environment you prefer, install Poetry and then use Poetry to install Parsita and its dependencies: pip install poetry poetry install Testing Parsita uses pytest to run the tests in the tests/ directory. The test command is encapsulated with Nox: nox -e test This will try to test with all compatible versions that nox can find. To run the tests with only a particular version, run something like this: nox -e test-3.9 It is good to run the tests locally before making a PR, but it is not necessary to have all Python versions run. It is rare for a failure to appear in a single version, and the CI will catch it anyway. Code quality Parsita uses Black, isort, and Flake8 to do ensure a minimum standard of code quality. The code quality commands are encapsulated with Nox: nox -e black nox -e isort nox -e lint Generating the docs Parsita uses MkDocs to generate HTML docs from Markdown. For development purposes, they can be served locally without needing to build them first: mkdocs serve To deploy the current docs to GitHub Pages, Parsita uses the MkDocs gh-deploy command that builds the static site on the gh-pages branch, commits, and pushes to the origin: mkdocs gh-deploy","title":"Contributing"},{"location":"contributing/#contributing","text":"Parsita is free and open source software developed under an MIT license. Development occurs at the GitHub project . Contributions, big and small, are welcome. Bug reports and feature requests may be made directly on the issues tab. To make a pull request, you will need to fork the repo, clone the repo, make the changes, run the tests, push the changes, and open a PR .","title":"Contributing"},{"location":"contributing/#cloning-the-repo","text":"To make a local copy of Parsita, clone the repository with git: git clone https://github.com/drhagen/parsita.git","title":"Cloning the repo"},{"location":"contributing/#installing-from-source","text":"Parsita uses Poetry as its packaging and dependency manager. In whatever Python environment you prefer, install Poetry and then use Poetry to install Parsita and its dependencies: pip install poetry poetry install","title":"Installing from source"},{"location":"contributing/#testing","text":"Parsita uses pytest to run the tests in the tests/ directory. The test command is encapsulated with Nox: nox -e test This will try to test with all compatible versions that nox can find. To run the tests with only a particular version, run something like this: nox -e test-3.9 It is good to run the tests locally before making a PR, but it is not necessary to have all Python versions run. It is rare for a failure to appear in a single version, and the CI will catch it anyway.","title":"Testing"},{"location":"contributing/#code-quality","text":"Parsita uses Black, isort, and Flake8 to do ensure a minimum standard of code quality. The code quality commands are encapsulated with Nox: nox -e black nox -e isort nox -e lint","title":"Code quality"},{"location":"contributing/#generating-the-docs","text":"Parsita uses MkDocs to generate HTML docs from Markdown. For development purposes, they can be served locally without needing to build them first: mkdocs serve To deploy the current docs to GitHub Pages, Parsita uses the MkDocs gh-deploy command that builds the static site on the gh-pages branch, commits, and pushes to the origin: mkdocs gh-deploy","title":"Generating the docs"},{"location":"conversion_parsers/","text":"Conversion parsers parser > function : conversion parser Conversion parsers don't change how the text is parsed\u2014they change the value returned. Every parser returns a value when it succeeds. The function supplied must take a single argument (the successful value) and returns a new value. This is how text is converted to other objects and simpler objects built into larger ones. In accordance with Python's operator precedence, > is the operator in Parsita with the loosest binding. from parsita import * class IntegerParsers ( TextParsers ): integer = reg ( r '[-+]?[0-9]+' ) > int assert IntegerParsers . integer . parse ( '-128' ) == Success ( - 128 )","title":"Conversion parsers"},{"location":"conversion_parsers/#conversion-parsers","text":"","title":"Conversion parsers"},{"location":"conversion_parsers/#parser-function-conversion-parser","text":"Conversion parsers don't change how the text is parsed\u2014they change the value returned. Every parser returns a value when it succeeds. The function supplied must take a single argument (the successful value) and returns a new value. This is how text is converted to other objects and simpler objects built into larger ones. In accordance with Python's operator precedence, > is the operator in Parsita with the loosest binding. from parsita import * class IntegerParsers ( TextParsers ): integer = reg ( r '[-+]?[0-9]+' ) > int assert IntegerParsers . integer . parse ( '-128' ) == Success ( - 128 )","title":"parser &gt; function: conversion parser"},{"location":"getting_started/","text":"Getting started David Hagen gave an introductory talk on Parsita at SciPy 2021. The documentation is more thorough, but the talk is useful for anyone looking for a quick walk-through. Defining a parser Parsita parsers are written inside the bodies of classes that inherit from TextParsers . (If you are parsing something other than a string, such a stream of tokens, there is the GeneralParsers class.) Such classes are not meant to be instantiated. They are used purely as a kind of souped-up context manager. The metaclass of TextParsers takes a whitespace named argument, which is a regular expression, or more commonly, a string that can be parsed into a regular expression. This becomes the definition of whitespace for all Parser s defined in this class body, making it so that whitespace as defined does not need to be explicitly captured and discarded. The default value is r'\\s*' \u2014all whitespace including newlines. With whitespace=None , no whitespace is ignored. from parsita import * class NumericListParsers ( TextParsers , whitespace = r '[ ]*' ): integer_list = '[' >> repsep ( reg ( '(+-)?[0-9]+' ) > int , ',' ) << ']' Pretty much every function in Parsita returns an object with type Parser . Various operators, like & and | , are defined so that Parser s can be combined to make new, more complex, parsers, hence the name \"parser combinators\". Invoking a parser Parser.parse The only method of note on a Parser is the parse method. The parse method takes a str as input and returns an instance of the Result class, which has two subclasses Success and Failure . The standard way to test if a result is a Success or Failure is to use isinstance(result, Success) . If Success , the parsed value can be obtained with result.value . If Failure , the error message can be obtained with result.message . from parsita import * class NumericListParsers ( TextParsers , whitespace = r '[ ]*' ): integer_list = '[' >> repsep ( reg ( '(+-)?[0-9]+' ) > int , ',' ) << ']' result = NumericListParsers . integer_list . parse ( '[1, 1, 2, 3, 5]' ) if isinstance ( result , Success ): python_list = result . value else : raise RuntimeError ( result . message ) Result.or_die Alternatively, result.or_die() returns the value if it is a Success and raises a ParseError exception with the message if it is a Failure . It is common to apply this immediately after the call to parse when an exception on failure is desired. from parsita import * class NumericListParsers ( TextParsers , whitespace = r '[ ]*' ): integer_list = '[' >> repsep ( reg ( '(+-)?[0-9]+' ) > int , ',' ) << ']' python_list = NumericListParsers . integer_list . parse ( '[1, 1, 2, 3, 5]' ) . or_die ()","title":"Getting started"},{"location":"getting_started/#getting-started","text":"David Hagen gave an introductory talk on Parsita at SciPy 2021. The documentation is more thorough, but the talk is useful for anyone looking for a quick walk-through.","title":"Getting started"},{"location":"getting_started/#defining-a-parser","text":"Parsita parsers are written inside the bodies of classes that inherit from TextParsers . (If you are parsing something other than a string, such a stream of tokens, there is the GeneralParsers class.) Such classes are not meant to be instantiated. They are used purely as a kind of souped-up context manager. The metaclass of TextParsers takes a whitespace named argument, which is a regular expression, or more commonly, a string that can be parsed into a regular expression. This becomes the definition of whitespace for all Parser s defined in this class body, making it so that whitespace as defined does not need to be explicitly captured and discarded. The default value is r'\\s*' \u2014all whitespace including newlines. With whitespace=None , no whitespace is ignored. from parsita import * class NumericListParsers ( TextParsers , whitespace = r '[ ]*' ): integer_list = '[' >> repsep ( reg ( '(+-)?[0-9]+' ) > int , ',' ) << ']' Pretty much every function in Parsita returns an object with type Parser . Various operators, like & and | , are defined so that Parser s can be combined to make new, more complex, parsers, hence the name \"parser combinators\".","title":"Defining a parser"},{"location":"getting_started/#invoking-a-parser","text":"","title":"Invoking a parser"},{"location":"getting_started/#parserparse","text":"The only method of note on a Parser is the parse method. The parse method takes a str as input and returns an instance of the Result class, which has two subclasses Success and Failure . The standard way to test if a result is a Success or Failure is to use isinstance(result, Success) . If Success , the parsed value can be obtained with result.value . If Failure , the error message can be obtained with result.message . from parsita import * class NumericListParsers ( TextParsers , whitespace = r '[ ]*' ): integer_list = '[' >> repsep ( reg ( '(+-)?[0-9]+' ) > int , ',' ) << ']' result = NumericListParsers . integer_list . parse ( '[1, 1, 2, 3, 5]' ) if isinstance ( result , Success ): python_list = result . value else : raise RuntimeError ( result . message )","title":"Parser.parse"},{"location":"getting_started/#resultor_die","text":"Alternatively, result.or_die() returns the value if it is a Success and raises a ParseError exception with the message if it is a Failure . It is common to apply this immediately after the call to parse when an exception on failure is desired. from parsita import * class NumericListParsers ( TextParsers , whitespace = r '[ ]*' ): integer_list = '[' >> repsep ( reg ( '(+-)?[0-9]+' ) > int , ',' ) << ']' python_list = NumericListParsers . integer_list . parse ( '[1, 1, 2, 3, 5]' ) . or_die ()","title":"Result.or_die"},{"location":"miscellaneous_parsers/","text":"Miscellaneous parsers pred(parser, predicate, description) : predicate parser A predicate parser matches parser and, if it succeeds, runs a test function predicate on the return value. If predicate returns True , the predicate parser succeeds, returning the same value; if it returns False , the parser fails with the message that it is expecting description . from parsita import * class IntervalParsers ( TextParsers ): number = reg ( '\\d+' ) > int pair = '[' >> number << ',' & number << ']' interval = pred ( pair , lambda x : x [ 0 ] <= x [ 1 ], 'ordered pair' ) assert IntervalParsers . interval . parse ( '[1, 2]' ) == Success ([ 1 , 2 ]) assert IntervalParsers . interval . parse ( '[2, 1]' ) != Success ([ 2 , 1 ]) any1 : any one element A parser that matches any single input element. This is not a particularly useful parser in the context of parsing text (for which reg(r'.') would be more standard). But in the GeneralParsers context, this is useful as the first argument to pred when one merely wants to run the predicate on a single token. This parser can only fail at the end of the stream. Note that any1 is not a function\u2014it is a complete parser itself. from parsita import * class DigitParsers ( GeneralParsers ): digit = pred ( any1 , lambda x : x [ 'type' ] == 'digit' , 'a digit' ) > \\ ( lambda x : x [ 'payload' ]) assert DigitParsers . digit . parse ([{ 'type' : 'digit' , 'payload' : 3 }]) == \\ Success ( 3 ) eof : end of file A parser than matches the end of the input stream. It is not necessary to include this on every parser. The parse method on every parser is successful only if it matches the entire input. The eof parser is only needed to indicate that the preceding parser is only valid at the end of the input. Most commonly, it is used an alternative to an end token when the end token may be omitted at the end of the input. Note that eof is not a function\u2014it is a complete parser itself. from parsita import * class OptionsParsers ( TextParsers ): option = reg ( r '[A-Za-z]+' ) << '=' & reg ( r '[A-Za-z]+' ) << ( ';' | eof ) options = rep ( option ) assert OptionsParsers . options . parse ( 'log=warn;detail=minimal;' ) == \\ Success ([[ 'log' , 'warn' ], [ 'detail' , 'minimal' ]]) assert OptionsParsers . options . parse ( 'log=warn;detail=minimal' ) == \\ Success ([[ 'log' , 'warn' ], [ 'detail' , 'minimal' ]]) fwd() : forward declaration This creates a forward declaration for a parser to be defined later. This function is not typically needed because forward declarations are created automatically within the class bodies of subclasses of TextParsers and GeneralParsers , which is the recommended way to use Parsita. This function exists so you can create a forward declaration manually because you are either working outside of the magic classes or wish to define them manually to make your IDE happier. To use fwd , first assign fwd() to a variable, then use that variable in other combinators like any other parser, then call the define(parser: Parser) method on the object to provide the forward declaration with its definition. The forward declaration will now look and act like the definition provided. from parsita import * class AddingParsers ( TextParsers ): number = reg ( r '[+-]?\\d+' ) > int expr = fwd () base = '(' >> expr << ')' | number expr . define ( rep1sep ( base , '+' ) > sum ) assert AddingParsers . expr . parse ( '2+(1+2)+3' ) == Success ( 8 ) success(value) : always succeed with value This parser always succeeds with the given value of an arbitrary type while consuming no input. Its utility is limited to inserting arbitrary values into complex parsers, often as a placeholder for unimplemented code. Usually, these kinds of values are better inserted as a post processing step or with a conversion parser > , but for prototyping, this parser can be convenient. from parsita import * class HostnameParsers ( TextParsers , whitespace = None ): port = success ( 80 ) # TODO: do not just ignore other ports host = rep1sep ( reg ( '[A-Za-z0-9]+([-]+[A-Za-z0-9]+)*' ), '.' ) server = host & port assert HostnameParsers . server . parse ( 'drhagen.com' ) == Success ([[ 'drhagen' , 'com' ], 80 ]) failure(expected) : always fail with message This parser always fails with a message that it is expecting the given string expected . Its utility is limited to marking sections of code as either not yet implemented or providing a better error message for common bad input. Usually, these kinds of messages are better crafted as a processing step following parsing, but for prototyping, they can be inserted with this parser. from parsita import * class HostnameParsers ( TextParsers , whitespace = None ): # TODO: implement allowing different port port = lit ( '80' ) | reg ( '[0-9]+' ) & failure ( 'no other port than 80' ) host = rep1sep ( reg ( '[A-Za-z0-9]+([-]+[A-Za-z0-9]+)*' ), '.' ) server = host << ':' & port assert HostnameParsers . server . parse ( 'drhagen.com:443' ) == \\ Failure ( 'Expected no other port than 80 but found end of source' )","title":"Miscellaneous parsers"},{"location":"miscellaneous_parsers/#miscellaneous-parsers","text":"","title":"Miscellaneous parsers"},{"location":"miscellaneous_parsers/#predparser-predicate-description-predicate-parser","text":"A predicate parser matches parser and, if it succeeds, runs a test function predicate on the return value. If predicate returns True , the predicate parser succeeds, returning the same value; if it returns False , the parser fails with the message that it is expecting description . from parsita import * class IntervalParsers ( TextParsers ): number = reg ( '\\d+' ) > int pair = '[' >> number << ',' & number << ']' interval = pred ( pair , lambda x : x [ 0 ] <= x [ 1 ], 'ordered pair' ) assert IntervalParsers . interval . parse ( '[1, 2]' ) == Success ([ 1 , 2 ]) assert IntervalParsers . interval . parse ( '[2, 1]' ) != Success ([ 2 , 1 ])","title":"pred(parser, predicate, description): predicate parser"},{"location":"miscellaneous_parsers/#any1-any-one-element","text":"A parser that matches any single input element. This is not a particularly useful parser in the context of parsing text (for which reg(r'.') would be more standard). But in the GeneralParsers context, this is useful as the first argument to pred when one merely wants to run the predicate on a single token. This parser can only fail at the end of the stream. Note that any1 is not a function\u2014it is a complete parser itself. from parsita import * class DigitParsers ( GeneralParsers ): digit = pred ( any1 , lambda x : x [ 'type' ] == 'digit' , 'a digit' ) > \\ ( lambda x : x [ 'payload' ]) assert DigitParsers . digit . parse ([{ 'type' : 'digit' , 'payload' : 3 }]) == \\ Success ( 3 )","title":"any1: any one element"},{"location":"miscellaneous_parsers/#eof-end-of-file","text":"A parser than matches the end of the input stream. It is not necessary to include this on every parser. The parse method on every parser is successful only if it matches the entire input. The eof parser is only needed to indicate that the preceding parser is only valid at the end of the input. Most commonly, it is used an alternative to an end token when the end token may be omitted at the end of the input. Note that eof is not a function\u2014it is a complete parser itself. from parsita import * class OptionsParsers ( TextParsers ): option = reg ( r '[A-Za-z]+' ) << '=' & reg ( r '[A-Za-z]+' ) << ( ';' | eof ) options = rep ( option ) assert OptionsParsers . options . parse ( 'log=warn;detail=minimal;' ) == \\ Success ([[ 'log' , 'warn' ], [ 'detail' , 'minimal' ]]) assert OptionsParsers . options . parse ( 'log=warn;detail=minimal' ) == \\ Success ([[ 'log' , 'warn' ], [ 'detail' , 'minimal' ]])","title":"eof: end of file"},{"location":"miscellaneous_parsers/#fwd-forward-declaration","text":"This creates a forward declaration for a parser to be defined later. This function is not typically needed because forward declarations are created automatically within the class bodies of subclasses of TextParsers and GeneralParsers , which is the recommended way to use Parsita. This function exists so you can create a forward declaration manually because you are either working outside of the magic classes or wish to define them manually to make your IDE happier. To use fwd , first assign fwd() to a variable, then use that variable in other combinators like any other parser, then call the define(parser: Parser) method on the object to provide the forward declaration with its definition. The forward declaration will now look and act like the definition provided. from parsita import * class AddingParsers ( TextParsers ): number = reg ( r '[+-]?\\d+' ) > int expr = fwd () base = '(' >> expr << ')' | number expr . define ( rep1sep ( base , '+' ) > sum ) assert AddingParsers . expr . parse ( '2+(1+2)+3' ) == Success ( 8 )","title":"fwd(): forward declaration"},{"location":"miscellaneous_parsers/#successvalue-always-succeed-with-value","text":"This parser always succeeds with the given value of an arbitrary type while consuming no input. Its utility is limited to inserting arbitrary values into complex parsers, often as a placeholder for unimplemented code. Usually, these kinds of values are better inserted as a post processing step or with a conversion parser > , but for prototyping, this parser can be convenient. from parsita import * class HostnameParsers ( TextParsers , whitespace = None ): port = success ( 80 ) # TODO: do not just ignore other ports host = rep1sep ( reg ( '[A-Za-z0-9]+([-]+[A-Za-z0-9]+)*' ), '.' ) server = host & port assert HostnameParsers . server . parse ( 'drhagen.com' ) == Success ([[ 'drhagen' , 'com' ], 80 ])","title":"success(value): always succeed with value"},{"location":"miscellaneous_parsers/#failureexpected-always-fail-with-message","text":"This parser always fails with a message that it is expecting the given string expected . Its utility is limited to marking sections of code as either not yet implemented or providing a better error message for common bad input. Usually, these kinds of messages are better crafted as a processing step following parsing, but for prototyping, they can be inserted with this parser. from parsita import * class HostnameParsers ( TextParsers , whitespace = None ): # TODO: implement allowing different port port = lit ( '80' ) | reg ( '[0-9]+' ) & failure ( 'no other port than 80' ) host = rep1sep ( reg ( '[A-Za-z0-9]+([-]+[A-Za-z0-9]+)*' ), '.' ) server = host << ':' & port assert HostnameParsers . server . parse ( 'drhagen.com:443' ) == \\ Failure ( 'Expected no other port than 80 but found end of source' )","title":"failure(expected): always fail with message"},{"location":"repeated_parsers/","text":"Repeated parsers rep(parser) and rep1(parser) : repeated parsers A repeated parser matches repeated instances of its parser argument. It returns a list with each element being the value of one match. rep1 only succeeds if at least one match is found. rep always succeeds, returning an empty list if no matches are found. from parsita import * class SummationParsers ( TextParsers ): integer = reg ( r '[-+]?[0-9]+' ) > int summation = integer & rep ( '+' >> integer ) > ( lambda x : sum ([ x [ 0 ]] + x [ 1 ])) assert SummationParsers . summation . parse ( '1 + 1 + 2 + 3 + 5' ) == Success ( 12 ) repsep(parser, separator) and rep1sep(parser, separator) : repeated separated parsers A repeated separated parser matches parser separated by separator, returning a list of the values returned by parser and discarding the value of separator. rep1sep only succeeds if at least one match is found. repsep always succeeds, returning an empty list if no matches are found. from parsita import * class ListParsers ( TextParsers ): integer = reg ( r '[-+]?[0-9]+' ) > int my_list = '[' >> repsep ( integer , ',' ) << ']' assert ListParsers . my_list . parse ( '[1,2,3]' ) == Success ([ 1 , 2 , 3 ])","title":"Repeated parsers"},{"location":"repeated_parsers/#repeated-parsers","text":"","title":"Repeated parsers"},{"location":"repeated_parsers/#repparser-and-rep1parser-repeated-parsers","text":"A repeated parser matches repeated instances of its parser argument. It returns a list with each element being the value of one match. rep1 only succeeds if at least one match is found. rep always succeeds, returning an empty list if no matches are found. from parsita import * class SummationParsers ( TextParsers ): integer = reg ( r '[-+]?[0-9]+' ) > int summation = integer & rep ( '+' >> integer ) > ( lambda x : sum ([ x [ 0 ]] + x [ 1 ])) assert SummationParsers . summation . parse ( '1 + 1 + 2 + 3 + 5' ) == Success ( 12 )","title":"rep(parser) and rep1(parser): repeated parsers"},{"location":"repeated_parsers/#repsepparser-separator-and-rep1sepparser-separator-repeated-separated-parsers","text":"A repeated separated parser matches parser separated by separator, returning a list of the values returned by parser and discarding the value of separator. rep1sep only succeeds if at least one match is found. repsep always succeeds, returning an empty list if no matches are found. from parsita import * class ListParsers ( TextParsers ): integer = reg ( r '[-+]?[0-9]+' ) > int my_list = '[' >> repsep ( integer , ',' ) << ']' assert ListParsers . my_list . parse ( '[1,2,3]' ) == Success ([ 1 , 2 , 3 ])","title":"repsep(parser, separator) and rep1sep(parser, separator): repeated separated parsers"},{"location":"sequential_parsers/","text":"Sequential parser parser1 & parser2 : sequential parser All the previous parsers will match at most one thing. This is the syntax for matching one parser and then another after it. If working in the TextParsers context, the two may be separated by whitespace. The value returned is a list of all the values returned by each parser. If there are multiple parsers separated by & , a list of the same length as the number of parsers is returned. Like | , either side may be a bare string, but not both. In accordance with Python's operator precedence, & binds more tightly than | . from parsita import * class UrlParsers ( TextParsers , whitespace = None ): url = lit ( 'http' , 'ftp' ) & '://' & reg ( r '[^/]+' ) & reg ( r '.*' ) assert UrlParsers . url . parse ( 'http://drhagen.com/blog/sane-equality/' ) == \\ Success ([ 'http' , '://' , 'drhagen.com' , '/blog/sane-equality/' ]) parser1 >> parser2 and parser1 << parser2 : discard left and right parsers The discard left and discard right parser match the exact same text as parser1 & parser2 , but rather than return a list of values from both, the left value in >> and the right value in << is discarded so that only the remaining value is returned. A mnemonic to help remember which is which is to imagine the symbols as open mouths eating the parser to be discarded. from parsita import * class PointParsers ( TextParsers ): integer = reg ( r '[-+]?[0-9]+' ) > int point = '(' >> integer << ',' & integer << ')' assert PointParsers . point . parse ( '(4, 3)' ) == Success ([ 4 , 3 ])","title":"Sequential parsers"},{"location":"sequential_parsers/#sequential-parser","text":"","title":"Sequential parser"},{"location":"sequential_parsers/#parser1-parser2-sequential-parser","text":"All the previous parsers will match at most one thing. This is the syntax for matching one parser and then another after it. If working in the TextParsers context, the two may be separated by whitespace. The value returned is a list of all the values returned by each parser. If there are multiple parsers separated by & , a list of the same length as the number of parsers is returned. Like | , either side may be a bare string, but not both. In accordance with Python's operator precedence, & binds more tightly than | . from parsita import * class UrlParsers ( TextParsers , whitespace = None ): url = lit ( 'http' , 'ftp' ) & '://' & reg ( r '[^/]+' ) & reg ( r '.*' ) assert UrlParsers . url . parse ( 'http://drhagen.com/blog/sane-equality/' ) == \\ Success ([ 'http' , '://' , 'drhagen.com' , '/blog/sane-equality/' ])","title":"parser1 &amp; parser2: sequential parser"},{"location":"sequential_parsers/#parser1-parser2-and-parser1-parser2-discard-left-and-right-parsers","text":"The discard left and discard right parser match the exact same text as parser1 & parser2 , but rather than return a list of values from both, the left value in >> and the right value in << is discarded so that only the remaining value is returned. A mnemonic to help remember which is which is to imagine the symbols as open mouths eating the parser to be discarded. from parsita import * class PointParsers ( TextParsers ): integer = reg ( r '[-+]?[0-9]+' ) > int point = '(' >> integer << ',' & integer << ')' assert PointParsers . point . parse ( '(4, 3)' ) == Success ([ 4 , 3 ])","title":"parser1 &gt;&gt; parser2 and parser1 &lt;&lt; parser2: discard left and right parsers"},{"location":"terminal_parsers/","text":"Terminal parsers Terminal parsers (those created by lit and reg ) are the atoms of a parser, they match and extract the smallest meaningful words of the language. You could say that they recognize the tokens of the language being parsed, but Parsita does not really have a concept of tokens, at least when using the TextParsers context. Terminal parsers chew directly on the input string. lit(*literals) : literal parser This is the simplest parser. It matches the exact string provided and returns the string as its value. If multiple arguments are provided, it tries each one in succession, returning the first one it finds. from parsita import * class HelloParsers ( TextParsers ): hello = lit ( 'Hello World!' ) assert HelloParsers . hello . parse ( 'Hello World!' ) == Success ( 'Hello World!' ) assert isinstance ( HelloParsers . hello . parse ( 'Goodbye' ), Failure ) In most cases, the call to lit is handled automatically. If a bare string is provided to the functions and operators below, it will be promoted to a literal parser whenever possible. Only when an operator is between two Python types, like a string and a string 'a' | 'b' or a string and function '100' > int will this \"implicit conversion\" not take place and you have to use lit (e.g. lit('a', 'b') and lit('100') > int ). reg(pattern) : regular expression parser Like lit , this matches a string and returns it, but the matching is done with a regular expression. from parsita import * class IntegerParsers ( TextParsers ): integer = reg ( r '[-+]?[0-9]+' ) assert IntegerParsers . integer . parse ( '-128' ) == Success ( '-128' )","title":"Terminal parsers"},{"location":"terminal_parsers/#terminal-parsers","text":"Terminal parsers (those created by lit and reg ) are the atoms of a parser, they match and extract the smallest meaningful words of the language. You could say that they recognize the tokens of the language being parsed, but Parsita does not really have a concept of tokens, at least when using the TextParsers context. Terminal parsers chew directly on the input string.","title":"Terminal parsers"},{"location":"terminal_parsers/#litliterals-literal-parser","text":"This is the simplest parser. It matches the exact string provided and returns the string as its value. If multiple arguments are provided, it tries each one in succession, returning the first one it finds. from parsita import * class HelloParsers ( TextParsers ): hello = lit ( 'Hello World!' ) assert HelloParsers . hello . parse ( 'Hello World!' ) == Success ( 'Hello World!' ) assert isinstance ( HelloParsers . hello . parse ( 'Goodbye' ), Failure ) In most cases, the call to lit is handled automatically. If a bare string is provided to the functions and operators below, it will be promoted to a literal parser whenever possible. Only when an operator is between two Python types, like a string and a string 'a' | 'b' or a string and function '100' > int will this \"implicit conversion\" not take place and you have to use lit (e.g. lit('a', 'b') and lit('100') > int ).","title":"lit(*literals): literal parser"},{"location":"terminal_parsers/#regpattern-regular-expression-parser","text":"Like lit , this matches a string and returns it, but the matching is done with a regular expression. from parsita import * class IntegerParsers ( TextParsers ): integer = reg ( r '[-+]?[0-9]+' ) assert IntegerParsers . integer . parse ( '-128' ) == Success ( '-128' )","title":"reg(pattern): regular expression parser"},{"location":"utility_functions/","text":"Utility functions There are several utility functions, constant , splat , and unsplat . They are mostly useful when used with the conversion parser ( > ). These utility functions are not exported by from parsita import * and must be imported from parsita.util . constant(value) : create a function that always returns the same value The function constant(value: A) -> Callable[..., A] accepts any single value and returns a function. The function takes any number of arguments of any types and returns value . It is useful for defining parsers (usually of a particular literal) that evaluate to a particular value. from parsita import * from parsita.util import constant class BooleanParsers ( TextParsers , whitespace = None ): true = lit ( 'true' ) > constant ( True ) false = lit ( 'false' ) > constant ( False ) boolean = true | false assert BooleanParsers . boolean . parse ( 'false' ) == Success ( False ) splat(function) : convert a function of many arguments to take only one list argument The function splat(function: Callable[Tuple[*B], A]) -> Callable[Tuple[Tuple[*B]], A] has a complicated type signature, but does a simple thing. It takes a single function that takes multiple arguments and converts it to a function that takes only one argument, which is a list of all original arguments. It is particularly useful for passing a list of results from a sequential parser & to a function that takes each element as an separate argument. By applying splat to the function, it now takes the single list that is returned by the sequential parser. from collections import namedtuple from parsita import * from parsita.util import splat Url = namedtuple ( 'Url' , [ 'host' , 'port' , 'path' ]) class UrlParsers ( TextParsers , whitespace = None ): host = reg ( r '[A-Za-z0-9.]+' ) port = reg ( r '[0-9]+' ) > int path = reg ( r '[-._~A-Za-z0-9/]*' ) url = 'https://' >> host << ':' & port & path > splat ( Url ) assert UrlParsers . url . parse ( 'https://drhagen.com:443/blog/' ) == \\ Success ( Url ( 'drhagen.com' , 443 , '/blog/' )) unsplat(function) : convert a function of one list argument to take many arguments The function unsplat(function: Callable[Tuple[Tuple[*B]], A]) -> Callable[Tuple[*B], A] does the opposite of splat . It takes a single function that takes a single argument that is a list and converts it to a function that takes multiple arguments, each of which was an element of the original list. It is not very useful for writing parsers because the conversion parser always calls its converter function with a single argument, but is included here to complement splat . from parsita.util import splat , unsplat def sum_args ( * x ): return sum ( x ) def sum_list ( x ): return sum ( x ) splatted_sum_args = splat ( sum_args ) unsplatted_sum_list = unsplat ( sum_list ) assert unsplatted_sum_list ( 2 , 3 , 5 ) == sum_args ( 2 , 3 , 5 ) assert splatted_sum_args ([ 2 , 3 , 5 ]) == sum_list ([ 2 , 3 , 5 ])","title":"Utility functions"},{"location":"utility_functions/#utility-functions","text":"There are several utility functions, constant , splat , and unsplat . They are mostly useful when used with the conversion parser ( > ). These utility functions are not exported by from parsita import * and must be imported from parsita.util .","title":"Utility functions"},{"location":"utility_functions/#constantvalue-create-a-function-that-always-returns-the-same-value","text":"The function constant(value: A) -> Callable[..., A] accepts any single value and returns a function. The function takes any number of arguments of any types and returns value . It is useful for defining parsers (usually of a particular literal) that evaluate to a particular value. from parsita import * from parsita.util import constant class BooleanParsers ( TextParsers , whitespace = None ): true = lit ( 'true' ) > constant ( True ) false = lit ( 'false' ) > constant ( False ) boolean = true | false assert BooleanParsers . boolean . parse ( 'false' ) == Success ( False )","title":"constant(value): create a function that always returns the same value"},{"location":"utility_functions/#splatfunction-convert-a-function-of-many-arguments-to-take-only-one-list-argument","text":"The function splat(function: Callable[Tuple[*B], A]) -> Callable[Tuple[Tuple[*B]], A] has a complicated type signature, but does a simple thing. It takes a single function that takes multiple arguments and converts it to a function that takes only one argument, which is a list of all original arguments. It is particularly useful for passing a list of results from a sequential parser & to a function that takes each element as an separate argument. By applying splat to the function, it now takes the single list that is returned by the sequential parser. from collections import namedtuple from parsita import * from parsita.util import splat Url = namedtuple ( 'Url' , [ 'host' , 'port' , 'path' ]) class UrlParsers ( TextParsers , whitespace = None ): host = reg ( r '[A-Za-z0-9.]+' ) port = reg ( r '[0-9]+' ) > int path = reg ( r '[-._~A-Za-z0-9/]*' ) url = 'https://' >> host << ':' & port & path > splat ( Url ) assert UrlParsers . url . parse ( 'https://drhagen.com:443/blog/' ) == \\ Success ( Url ( 'drhagen.com' , 443 , '/blog/' ))","title":"splat(function): convert a function of many arguments to take only one list argument"},{"location":"utility_functions/#unsplatfunction-convert-a-function-of-one-list-argument-to-take-many-arguments","text":"The function unsplat(function: Callable[Tuple[Tuple[*B]], A]) -> Callable[Tuple[*B], A] does the opposite of splat . It takes a single function that takes a single argument that is a list and converts it to a function that takes multiple arguments, each of which was an element of the original list. It is not very useful for writing parsers because the conversion parser always calls its converter function with a single argument, but is included here to complement splat . from parsita.util import splat , unsplat def sum_args ( * x ): return sum ( x ) def sum_list ( x ): return sum ( x ) splatted_sum_args = splat ( sum_args ) unsplatted_sum_list = unsplat ( sum_list ) assert unsplatted_sum_list ( 2 , 3 , 5 ) == sum_args ( 2 , 3 , 5 ) assert splatted_sum_args ([ 2 , 3 , 5 ]) == sum_list ([ 2 , 3 , 5 ])","title":"unsplat(function): convert a function of one list argument to take many arguments"}]}